<!DOCTYPE html>
<!--09_09_01_ES6.html--->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>

    // spread

    const fruits = ['사과', '바나나'];
    const moreFruits = ['오렌지', '딸기'];

    // 1. 배열 합치기: ...을 사용해서 fruits와 moreFruits를 펼쳐서 새로운 배열에 넣는다.
    const allFruits = [...fruits, ...moreFruits, '포도'];
    console.log('모든 과일:', allFruits); // 출력: ['사과', '바나나', '오렌지', '딸기', '포도']

    // 2. 배열 복사하기: ...을 사용해서 기존 배열의 내용만 똑같이 복사해서 새로운 배열을 만들기
    const copiedFruits = [...fruits];
    console.log('복사된 과일:', copiedFruits); // 출력: ['사과', '바나나']
    console.log('원본과 복사본은 같을까?', fruits === copiedFruits); // 출력: false (완전히 다른 새 배열임!)

    // 3. 함수에 배열 값 전달: 배열의 요소들을 하나씩 함수의 매개변수로 전달하고 싶을 때
    function sum(a, b, c) {
        return a + b + c;
    }
    const numbers = [1, 2, 3];
    console.log('합계:', sum(...numbers)); // 출력: 6 (sum(1, 2, 3)과 같음)




    // spread 를 통해 객체를 펼치기

    const user = { name: '초록자두', age: 38 };
    const userInfo = { email: 'greenplum@velog.com', age: 32, city: '서울' }; // age가 중복!

    // 1. 객체 합치기: ...을 사용해서 user와 userInfo 객체를 펼쳐서 새로운 객체에 넣는다.
    // 이때, 같은 이름의 속성이 있으면 뒤에 오는 값이 덮어 씌워진다.
    const mergedUser = { ...user, ...userInfo, hobby: '독서' };
    console.log('합쳐진 사용자 정보:', mergedUser);

    // 2. 객체 복사하기: ...을 사용해서 기존 객체의 내용만 똑같이 복사해서 새로운 객체를 만든다.
    const copiedUser = { ...user };
    console.log('복사된 사용자:', copiedUser);
    console.log('원본과 복사본은 같을까?', user === copiedUser); // 출력: false (완전히 다른 새 객체이다!)




    // optional chaining (?.)

    const user1 = {
        name: '길동',
        address: {
            city: '서울',
            zipcode: '12345'
        },
        getPhoneNumber: function() {
            return '010-1234-5678';
        }
    };

    const user2 = {
        name: '영희' // address 속성이 없다.
    };

    const user3 = {
        name: '철수',
        address: null // address는 있지만 값이 null이다.
    };

    // user1은 모든 정보가 있다.
    console.log('user1 도시:', user1.address.city); // 출력: 서울
    console.log('user1 전화번호:', user1.getPhoneNumber()); // 출력: 010-1234-5678

    // user2는 address가 없다.
    // console.log('user2 도시:', user2.address.city); // 에러 ! 'address'가 없는데 '.city'에 접근하려 함
    console.log('user2 도시 (옵셔널 체이닝):', user2.address?.city); // 출력: undefined (에러 없이!)
    console.log('user2 전화번호 (옵셔널 체이닝):', user2.getPhoneNumber?.()); // 출력: undefined (메서드가 없으면 호출 안함)

    // user3는 address가 null이다.
    console.log('user3 도시 (옵셔널 체이닝):', user3.address?.city); // 출력: undefined (에러 없이! )

    // 함수 호출에도 사용 가능
    const someFunction = null;
    // someFunction(); //  에러 발생! 'someFunction'이 null인데 호출하려 함
    someFunction?.(); // 에러 없이 아무것도 안 함



    // nullish coalscing

    let username = null;
    let defaultUsername = '손님';

    console.log('사용자 이름 (nullish):', username ?? defaultUsername); // 출력: 손님 (username이 null이므로 defaultUsername 사용)

    let age = 0; // age는 0, 이것도 유효한 값, 0도 값임.
    let defaultAge = 20;

    console.log('나이 (nullish):', age ?? defaultAge); // 출력: 0 (age가 0이므로 0 사용)
    console.log('나이 (OR 연산자):', age || defaultAge); // 출력: 20 (age가 0이면 false로 간주하여 defaultAge 사용. 이게 차이점!)

    let email = ''; // email은 빈 문자열, 이것도 유효한 값 [아무것도 없다고 생각할 수 있지만 컴퓨터는 빈문자열도 인식함]
    let defaultEmail = 'unknown@example.com';

    console.log('이메일 (nullish):', email ?? defaultEmail); // 출력: '' (email이 빈 문자열이므로 빈 문자열 사용)
    console.log('이메일 (OR 연산자):', email || defaultEmail); // 출력: unknown@example.com (email이 빈 문자열이면 false로 간주하여 defaultEmail 사용)

    let message = '안녕하세요';
    let defaultMessage = '환영합니다';
    console.log('메시지 (nullish):', message ?? defaultMessage); // 출력: 안녕하세요 (message가 null이나 undefined가 아니므로 message 사용)





</script>

</body>
</html>